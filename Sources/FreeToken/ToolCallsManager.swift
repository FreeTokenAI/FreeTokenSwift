//
//  ToolCallsManager.swift
//  FreeToken
//
//  Created by Vince Francesi on 2/4/25.
//

import Foundation

extension FreeToken {
    class ToolCallsManager: @unchecked Sendable {
        private let rawToolCalls: String
        
        private let availableCloudToolCalls: [String]
        private let internalLocalToolCalls = ["article_lookup", "web_search", "void"]
        private let documentSearchScope: String?
        
        private var result: String = ""
        private var toolCalls: [ToolCall] = []
        
        private let unhandledInternalToolCallError = Codings.ErrorResponse(error: "unhandledInternalToolCall", message: "A tool call was classified as internal, but was not handled by code. This could happen if your client is out of date.", code: 4000)
        
        internal init(toolCalls rawToolCalls: String, availableCloudToolCalls: [String], documentSearchScope: String?) {
            self.rawToolCalls = rawToolCalls
            self.availableCloudToolCalls = availableCloudToolCalls
            self.documentSearchScope = documentSearchScope
            
            self.result = """
                This message is generated by the application and the user CANNOT see it. It includes the results of the application tool calls. Use these results to answer the user's question:
            """
        }
        
        actor ToolCallResultsCollector {
            var toolResults: [String] = []
            
            func appendResult(_ result: String) {
                toolResults.append(result)
            }
            
            func getResults() -> String {
                return toolResults.joined(separator: "\n\n")
            }
        }
        
        internal func process(
            externalToolCallHandler: Optional<@Sendable ([ToolCall]) -> String> = nil,
            cloudToolCallHandler: @escaping @Sendable ([ToolCall]) -> String,
            success successCallback: @escaping @Sendable (_ result: String) -> Void
        ) throws {
            try parseToolCalls()

            if toolCalls.isEmpty {
                successCallback("")
                return
            }

            let remainingToolCalls = toolCalls.filter { toolCall in
                let isCloudCall = availableCloudToolCalls.contains { $0 == toolCall.name }
                let isInternalCall = internalLocalToolCalls.contains { $0 == toolCall.name }
                return !isCloudCall && !isInternalCall
            }

            let cloudToolCalls = toolCalls.filter { availableCloudToolCalls.contains($0.name) }
            let internalCalls = toolCalls.filter { internalLocalToolCalls.contains($0.name) }

            let toolCallResultsCollector = ToolCallResultsCollector()
            let dispatchGroup = DispatchGroup()

            func launchTask(_ task: @Sendable @escaping () async -> Void) {
                dispatchGroup.enter()
                Task {
                    defer { dispatchGroup.leave() }
                    await task()
                }
            }

            if !cloudToolCalls.isEmpty {
                launchTask { [self] in
                    let result = await self.handleInternalCloudCalls(toolCalls: cloudToolCalls, cloudToolCallHandler: cloudToolCallHandler)
                    await toolCallResultsCollector.appendResult(result)
                }
            }

            if !remainingToolCalls.isEmpty {
                launchTask { [self] in
                    let result = await self.handleExternalCalls(toolCalls: remainingToolCalls, externalToolCallHandler: externalToolCallHandler)
                    await toolCallResultsCollector.appendResult(result)
                }
            }

            if !internalCalls.isEmpty {
                launchTask { [self] in
                    let result = await self.handleInternalLocalCalls(toolCalls: internalCalls)
                    await toolCallResultsCollector.appendResult(result)
                }
            }

            // If all lists are empty, notify immediately (avoid hanging)
            if cloudToolCalls.isEmpty && remainingToolCalls.isEmpty && internalCalls.isEmpty {
                successCallback("")
                return
            }

            dispatchGroup.notify(queue: .main) {
                Task {
                    let results = await toolCallResultsCollector.getResults()
                    successCallback(results)
                }
            }
        }
        
        private func parseToolCalls() throws {
            let parser = ParseToolCalls(toolCalls: rawToolCalls)
            try parser.call()
            
            self.toolCalls = parser.parsedTools.map { toolCall in
                var name: String = ""
                var args: [String: String] = [:]
                if case let .name(n) = toolCall["name"], case let .arguments(a) = toolCall["arguments"] {
                    name = n
                    args = a
                }
                
                return ToolCall(name: name, arguments: args)
            }
        }
        
        private func handleInternalLocalCalls(toolCalls: [ToolCall]) async -> String {
            var results = ""
            
            for toolCall in toolCalls {
                do {
                    let result = try await handleInternalLocalCall(toolCall: toolCall)
                    results += result
                } catch {
                    FreeToken.shared.logger("Error handling internal local call: \(error)", .error)
                }
            }
            
            return results
        }
        
        private func handleInternalLocalCall(toolCall: ToolCall) async throws -> String {
            if toolCall.name == "article_lookup", let query = toolCall.arguments["query"] {
                return await withCheckedContinuation { continuation in
                    internal_articleLookup(query: query, searchScope: documentSearchScope) { result in
                        continuation.resume(returning: result)
                    }
                }
            } else if toolCall.name == "web_search", let query = toolCall.arguments["query"] {
                return await withCheckedContinuation { continuation in
                    internal_webSearch(query: query, freshness: toolCall.arguments["freshness"]) { result in
                        continuation.resume(returning: result)
                    }
                }
            } else if toolCall.name == "void" {
                return ""
            } else {
                throw FreeTokenError.convertErrorResponse(errorResponse: unhandledInternalToolCallError)
            }
        }
        
        private func handleInternalCloudCalls(toolCalls: [ToolCall], cloudToolCallHandler: @escaping @Sendable ([ToolCall]) -> String) async -> String {
            if toolCalls.isEmpty {
                return ""
            }
            return cloudToolCallHandler(toolCalls)
        }
        
        private func handleExternalCalls(toolCalls: [ToolCall], externalToolCallHandler: Optional<@Sendable ([ToolCall]) -> String> = nil) async -> String {
            if toolCalls.isEmpty || externalToolCallHandler == nil {
                return ""
            }
            return externalToolCallHandler!(toolCalls)
        }
        
        private func internal_articleLookup(query: String, searchScope: String?, success successCallback: @escaping @Sendable (_ result: String) -> Void) {
            FreeToken.shared.searchDocuments(query: query, searchScope: searchScope, maxResults: 3) { searchResults in
                var result = "Article excerpts to help answer the user's question:"
                
                for documentChunk in searchResults.documentChunks {
                    var metadata = ""
                    if documentChunk.documentMetadata != nil {
                        metadata = documentChunk.documentMetadata!
                    }
                    
                    result.append("""
                    \(metadata)
                    
                    \(documentChunk.contentChunk)
                
                """)
                }
                
                successCallback(result)
            } error: { error in
                // NoOp
                FreeToken.shared.logger("Internal article lookup failed to retrieve documents from cloud. Ignoring", .warning)
                successCallback("")
            }
        }
        
        private func internal_webSearch(query: String, freshness: String? = nil, success successCallback: @escaping @Sendable (_ result: String) -> Void) {
            var freshnessEnum: FreeToken.WebSearchFreshness? = nil
            
            if freshness != nil {
                freshnessEnum = FreeToken.WebSearchFreshness(rawValue: freshness!)
            }
            
            FreeToken.shared.webSearch(query: query, freshness: freshnessEnum) { searchResults in
                var result = "Web search results to help answer the user's question:"
                
                for webResult in searchResults {
                    result.append("""
                    =================================================
                    WEB SEARCH RESULT: 
                    NAME: \(webResult.name)
                    URL: \(webResult.url)
                    DATE PUBLISHED: \(webResult.datePublished ?? "Unknown")
                    DATE LAST CRAWLED: \(webResult.dateLastCrawled ?? "Unknown")
                    RESULT CONTENT: 
                    \(webResult.summary)
                """)
                }
                
                successCallback(result)
            } error: { error in
                // NoOp
                FreeToken.shared.logger("Internal web search failed to retrieve documents from cloud. Ignoring", .warning)
                successCallback("")
            }
        }
    }
}
