//
//  ToolCallsManager.swift
//  FreeToken
//
//  Created by Vince Francesi on 2/4/25.
//

import Foundation

extension FreeToken {
    class ToolCallsManager: @unchecked Sendable {
        private let rawToolCalls: String
        
        private let availableCloudToolCalls: [String]
        private let internalLocalToolCalls = ["article_lookup", "void"]
        private let documentSearchScope: String?
        
        private var result: String = ""
        private var toolCalls: [ToolCall] = []
        
        private let unhandledInternalToolCallError = Codings.ErrorResponse(error: "unhandledInternalToolCall", message: "A tool call was classified as internal, but was not handled by code. This could happen if your client is out of date.", code: 4000)
        
        internal init(toolCalls rawToolCalls: String, availableCloudToolCalls: [String], documentSearchScope: String?) {
            self.rawToolCalls = rawToolCalls
            self.availableCloudToolCalls = availableCloudToolCalls
            self.documentSearchScope = documentSearchScope
            
            self.result = """
                This message is generated by the application and the user CANNOT see it. It includes the results of the application tool calls. Use these results to answer the user's question:
            """
        }
        
        actor ToolCallResultsCollector {
            var toolResults: [String] = []
            
            func appendResult(_ result: String) {
                toolResults.append(result)
            }
            
            func getResults() -> String {
                return toolResults.joined(separator: "\n\n")
            }
        }
        
        internal func process(externalToolCallHandler: Optional<@Sendable ([ToolCall]) -> String> = nil, cloudToolCallHandler: @escaping @Sendable ([ToolCall]) -> String, success successCallback: @escaping @Sendable (_ result: String) -> Void) throws {
            try parseToolCalls()

            if toolCalls.isEmpty {
                successCallback("")
                return
            }

            let remainingToolCalls: [ToolCall] = toolCalls.filter { toolCall in
                let isCloudCall = availableCloudToolCalls.contains { $0 == toolCall.name }
                let isInternalCall = internalLocalToolCalls.contains { $0 == toolCall.name }
                return !isCloudCall && !isInternalCall
            }

            let cloudToolCalls = toolCalls.filter { availableCloudToolCalls.contains($0.name) }
            let internalCalls = toolCalls.filter { internalLocalToolCalls.contains($0.name) }

            let toolCallResultsCollector = ToolCallResultsCollector()
            let dispatchGroup = DispatchGroup()

            if !cloudToolCalls.isEmpty {
                dispatchGroup.enter()
                Task {
                    let result = await self.handleInternalCloudCalls(toolCalls: cloudToolCalls, cloudToolCallHandler: cloudToolCallHandler)
                    await toolCallResultsCollector.appendResult(result)
                    dispatchGroup.leave()
                }
            }

            if !remainingToolCalls.isEmpty {
                dispatchGroup.enter()
                Task {
                    let result = await self.handleExternalCalls(toolCalls: remainingToolCalls, externalToolCallHandler: externalToolCallHandler)
                    await toolCallResultsCollector.appendResult(result)
                    dispatchGroup.leave()
                }
            }

            if !internalCalls.isEmpty {
                dispatchGroup.enter()
                Task {
                    let result = await self.handleInternalLocalCalls(toolCalls: internalCalls)
                    await toolCallResultsCollector.appendResult(result)
                    dispatchGroup.leave()
                }
            }

            dispatchGroup.notify(queue: .main) {
                Task {
                    successCallback(await toolCallResultsCollector.getResults())
                }
            }
        }
        
        private func parseToolCalls() throws {
            let parser = ParseToolCalls(toolCalls: rawToolCalls)
            try parser.call()
            
            self.toolCalls = parser.parsedTools.map { toolCall in
                var name: String = ""
                var args: [String: String] = [:]
                if case let .name(n) = toolCall["name"], case let .arguments(a) = toolCall["arguments"] {
                    name = n
                    args = a
                }
                
                return ToolCall(name: name, arguments: args)
            }
        }
        
        private func handleInternalLocalCalls(toolCalls: [ToolCall]) async -> String {
            var results = ""
            
            for toolCall in toolCalls {
                do {
                    let result = try await handleInternalLocalCall(toolCall: toolCall)
                    results += result
                } catch {
                    print("[FreeToken] Error handling internal local call: \(error)")
                }
            }
            
            return results
        }
        
        private func handleInternalLocalCall(toolCall: ToolCall) async throws -> String {
            if toolCall.name == "article_lookup", let query = toolCall.arguments["query"] {
                return await withCheckedContinuation { continuation in
                    internal_articleLookup(query: query, searchScope: documentSearchScope) { result in
                        continuation.resume(returning: result)
                    }
                }
            } else if toolCall.name == "void" {
                return ""
            } else {
                throw FreeTokenError.convertErrorResponse(errorResponse: unhandledInternalToolCallError)
            }
        }
        
        private func handleInternalCloudCalls(toolCalls: [ToolCall], cloudToolCallHandler: @escaping @Sendable ([ToolCall]) -> String) async -> String {
            if toolCalls.isEmpty {
                return ""
            }
            return cloudToolCallHandler(toolCalls)
        }
        
        private func handleExternalCalls(toolCalls: [ToolCall], externalToolCallHandler: Optional<@Sendable ([ToolCall]) -> String> = nil) async -> String {
            if toolCalls.isEmpty || externalToolCallHandler == nil {
                return ""
            }
            return externalToolCallHandler!(toolCalls)
        }
        
        private func internal_articleLookup(query: String, searchScope: String?, success successCallback: @escaping @Sendable (_ result: String) -> Void) {
            FreeToken.shared.searchDocuments(query: query, searchScope: searchScope, maxResults: 3) { searchResults in
                var result = "Article excerpts to help answer the user's question:"
                
                for documentChunk in searchResults.documentChunks {
                    var metadata = ""
                    if documentChunk.documentMetadata != nil {
                        metadata = documentChunk.documentMetadata!
                    }
                    
                    result.append("""
                    \(metadata)
                    
                    \(documentChunk.contentChunk)
                
                """)
                }
                
                successCallback(result)
            } error: { error in
                // NoOp
                print("[FreeToken] Internal article lookup failed to retrieve documents from cloud. Ignoring")
                successCallback("")
            }
        }
    }
}
